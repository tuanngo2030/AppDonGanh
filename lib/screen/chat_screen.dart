import 'package:don_ganh_app/models/chat_model.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:socket_io_client/socket_io_client.dart' as IO;
import 'package:shared_preferences/shared_preferences.dart';

class ChatScreen extends StatefulWidget {
  final String title;
  final String userId; // ID của người dùng hiện tại
  final String conversationId;

  const ChatScreen({
    super.key,
    required this.title,
    required this.userId,
    required this.conversationId,
  });

  @override
  _ChatScreenState createState() => _ChatScreenState();
}

class _ChatScreenState extends State<ChatScreen> {
  final TextEditingController _controller = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  IO.Socket? socket;
  String? token;
  List<Message> messages = [];

  @override
  void initState() {
    super.initState();
    _loadTokenAndConnect();
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _controller.dispose();
    socket?.disconnect();
    socket?.dispose();
    super.dispose();
  }

  Future<void> _loadTokenAndConnect() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    token = prefs.getString('token');

    if (token != null) {
      connect();
    } else {
      print("Token not found");
    }
  }

 void connect() {
  // Hủy bỏ các sự kiện nếu socket đã tồn tại
  socket?.off('Joined');
  socket?.off('message');
  socket?.off('error');
  socket?.off('disconnect');
  socket?.off('reconnect');

  // Tạo socket mới
  socket = IO.io(
    "https://imp-model-widely.ngrok-free.app",
    <String, dynamic>{
      "transports": ["websocket"],
      "autoConnect": true,
      "reconnection": true,
      'auth': {
        'token': token,
      }
    },
  );

  socket!.connect();

  // Thêm các sự kiện sau khi socket được kết nối
  socket!.onConnect((_) {
    print("Connected to the server");
    socket!.emit("join", {
      'token': token,
      'conversationId': widget.conversationId,
    });
  });

  socket!.on('Joined', (data) {
    List<dynamic> previousMessages = data['messages'];
    for (var msg in previousMessages) {
      addMessage(Message.fromJson(msg));
    }
    print("Joined conversation with messages: $data");
  });

  // Listen for incoming messages
  socket!.on('message', (data) {
    final message = Message(
      id: data['message']['_id'], // Assuming the server sends back the generated ID
      text: data['message']['text'],
      seen: false,
      msgByUserId: data['message']['msgByUserId'], // Adjust as necessary
      createdAt: DateTime.now(), // Use appropriate timestamp
      updatedAt: DateTime.now(), // Use appropriate timestamp
    );

    // Add received message to the list
    addMessage(message);
  });

  socket!.on('error', (data) {
    print('Error: ${data['message']}');
  });

  socket!.onDisconnect((_) {
    print("Disconnected from the server");
  });

  socket!.onReconnect((_) {
    print("Reconnected to the server");
    socket!.emit("join", {
      'token': token,
      'conversationId': widget.conversationId,
    });
  });
}

  void sendMessage(String text) {
    if (text.isEmpty) return;

    try {
      if (socket != null && socket!.connected) {
        // Send message
        // socket!.emit('sendMessage', message.toJson());

        socket!.emit('sendMessage', {
          'conversationId': widget.conversationId,
          'text': text,
        });

        final message = Message(
          id: '', // ID will be generated by the server
          text: text,
          seen: false,
          msgByUserId: widget.userId,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );

        // Add message to the list
        addMessage(message);

        _controller.clear();
        // _scrollToBottom();
      } else {
        print("Socket is not connected.");
      }
    } catch (e) {
      print("Error sending message: $e");
    }
  }

void addMessage(Message message) {
  if (mounted) {
    setState(() {
      messages.add(message);
    });
    // Gọi _scrollToBottom() sau khi cập nhật danh sách tin nhắn
    Future.delayed(const Duration(milliseconds: 100), _scrollToBottom);
  }
}

  void _scrollToBottom() {
    if (_scrollController.hasClients) {
      _scrollController.animateTo(
        _scrollController.position.maxScrollExtent,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
        backgroundColor: Colors.green[700],
      ),
      body: Column(
        children: <Widget>[
          Expanded(
            child: ListView.builder(
              // reverse: true,
              controller: _scrollController,
              itemCount: messages.length,
              itemBuilder: (context, index) {
                final message = messages[index];
                return ChatBubble(
                  message: message.text,
                  time: DateFormat('HH:mm').format(message.createdAt),
                  isUserMessage: message.msgByUserId ==
                      widget.userId, // So sánh với userId
                  seen: message.seen,
                );
              },
            ),
          ),
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: Row(
              children: <Widget>[
                Expanded(
                  child: TextFormField(
                    controller: _controller,
                    decoration: InputDecoration(
                      hintText: 'Nhập tin nhắn...',
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(20),
                      ),
                    ),
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.send),
                  onPressed: () => sendMessage(_controller.text),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class ChatBubble extends StatelessWidget {
  final String message;
  final String time;
  final bool isUserMessage;
  final bool seen;

  const ChatBubble({
    super.key,
    required this.message,
    required this.time,
    required this.isUserMessage,
    this.seen = false,
  });

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: isUserMessage
          ? Alignment.centerRight
          : Alignment.centerLeft, // Căn chỉnh theo điều kiện
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 5.0, horizontal: 10.0),
        child: Column(
          crossAxisAlignment:
              isUserMessage ? CrossAxisAlignment.end : CrossAxisAlignment.start,
          children: [
            Container(
              padding: const EdgeInsets.all(12.0),
              decoration: BoxDecoration(
                color: isUserMessage
                    ? Colors.green[200]
                    : Colors.grey[300], // Màu sắc cho tin nhắn
                borderRadius: BorderRadius.circular(15),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    message,
                    style: TextStyle(
                      fontSize: 16,
                      color: isUserMessage ? Colors.black : Colors.black87,
                    ),
                  ),
                  if (seen) const SizedBox(height: 5),
                  if (seen)
                    const Text(
                      'Đã đọc',
                      style: TextStyle(fontSize: 12, color: Colors.green),
                    ),
                ],
              ),
            ),
            const SizedBox(height: 2),
            Text(
              time,
              style: const TextStyle(fontSize: 12, color: Colors.grey),
            ),
          ],
        ),
      ),
    );
  }
}
